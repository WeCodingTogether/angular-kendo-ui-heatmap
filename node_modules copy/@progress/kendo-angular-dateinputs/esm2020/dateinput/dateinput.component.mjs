/**-----------------------------------------------------------------------------------------
* Copyright © 2023 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, ChangeDetectionStrategy, ChangeDetectorRef, Input, Output, ViewChild, EventEmitter, ElementRef, HostBinding, isDevMode, Renderer2, forwardRef, NgZone, Optional, Injector } from '@angular/core';
import { minValidator } from '../validators/min.validator';
import { maxValidator } from '../validators/max.validator';
import { incompleteDateValidator } from '../validators/incomplete-date.validator';
import { NG_VALUE_ACCESSOR, NG_VALIDATORS, NgControl } from '@angular/forms';
import { L10N_PREFIX, LocalizationService } from '@progress/kendo-angular-l10n';
import { IntlService, localeData } from '@progress/kendo-angular-intl';
import { validatePackage } from '@progress/kendo-licensing';
import { packageMetadata } from '../package-metadata';
import { cloneDate, isEqual } from '@progress/kendo-date-math';
import { hasObservers, KendoInput } from '@progress/kendo-angular-common';
import { Arrow } from './arrow.enum';
import { noop, isValidRange, getSizeClass, getRoundedClass, getFillModeClass, DEFAULT_FILL_MODE, DEFAULT_ROUNDED, DEFAULT_SIZE } from '../util';
import { PickerService } from '../common/picker.service';
import { closest } from '../common/dom-queries';
import { requiresZoneOnBlur, isPresent, attributeNames } from '../common/utils';
import { Subscription } from 'rxjs';
import { caretAltDownIcon, caretAltUpIcon } from '@progress/kendo-svg-icons';
import { DateInput } from '@progress/kendo-dateinputs-common';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-intl";
import * as i2 from "@progress/kendo-angular-l10n";
import * as i3 from "../common/picker.service";
import * as i4 from "@progress/kendo-angular-icons";
import * as i5 from "./localization/dateinput-localized-messages.directive";
import * as i6 from "@progress/kendo-angular-common";
import * as i7 from "@angular/common";
let nextId = 0;
const MIN_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-min';
const MAX_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/api/DateInputComponent/#toc-max';
const VALUE_DOC_LINK = 'http://www.telerik.com/kendo-angular-ui/components/dateinputs/dateinput/#toc-using-with-json';
const TWO_DIGIT_YEAR_MAX = 68;
const DEFAULT_FORMAT = 'd';
const DEFAULT_FORMAT_PLACEHOLDER = 'wide';
const DATE_PART_REGEXP = /year|month|<day>/;
const TIME_PART_REGEXP = /hour|minute|second|millisecond/;
/**
 * @hidden
 * Need to overrite `dateFormatNames` parameters order and provide `cldr` object
 * required by the kendo-dateinputs-common package
 */
export class DateInputIntl {
    constructor(service) {
        this.service = service;
        this.cldr = {};
        this.localeId = service['localeId'];
        this.format = service.format;
        this.toString = service.toString;
        this.formatDate = service.formatDate;
        this.parseDate = service.parseDate;
        this.parseNumber = service.parseNumber;
        this.formatNumber = service.formatNumber;
        this.splitDateFormat = service.splitDateFormat;
        this.numberSymbols = service.numberSymbols;
        this.firstDay = service.firstDay;
        this.weekendRange = service.weekendRange;
        this.dateFieldName = service.dateFieldName;
        this.dateFormatNames = (localeId, options) => this.service.dateFormatNames(options, localeId || this.localeId);
        const _localeData = localeData(this.localeId);
        // Setting the `cldr` object from here could be avoided if the logic in the common package is revisited to 
        // directly relies on the `localeId` being set as part of the options => TBD and validated for all suites
        this.cldr[_localeData.name] = _localeData;
    }
}
/**
 * Represents the [Kendo UI DateInput component for Angular]({% slug overview_dateinput %}#toc-basic-usage).
 */
export class DateInputComponent {
    constructor(cdr, intl, renderer, wrapper, ngZone, injector, localization, pickerService) {
        this.cdr = cdr;
        this.intl = intl;
        this.renderer = renderer;
        this.wrapper = wrapper;
        this.ngZone = ngZone;
        this.injector = injector;
        this.localization = localization;
        this.pickerService = pickerService;
        /**
         * @hidden
         */
        this.caretAltUpIcon = caretAltUpIcon;
        /**
         * @hidden
         */
        this.caretAltDownIcon = caretAltDownIcon;
        /**
         * Sets or gets the `disabled` property of the DateInput and
         * determines whether the component is active
         * ([see example]({% slug disabled_dateinput %})).
         */
        this.disabled = false;
        /**
         * Sets or gets the read-only state of the DateInput
         * ([see example]({% slug readonly_dateinput %})).
         */
        this.readonly = false;
        /**
         * Sets the title of the input element of the DateInput.
         */
        this.title = "";
        /**
         * Sets or gets the `tabIndex` property of the DateInput.
         * .
         */
        this.tabindex = 0;
        /**
         * @hidden
         */
        this.role = 'textbox';
        /**
         * @hidden
         */
        this.ariaReadOnly = false;
        /**
         * Specifies the date format that is used to display the input value
         * ([see example]({% slug formats_dateinput %})).
         *
         * Format value options:
         * - `string` - Provide a `string` if a single format is going to be used regardless whether the input is focused or blurred.
         * - [`FormatSettings`]({% slug api_dateinputs_formatsettings %}) - To display different formats when the component is focused or blurred, provide a settings object with specified `inputFormat` and `displayFormat` values.
         */
        this.format = DEFAULT_FORMAT;
        /**
         * Specifies the hint the DateInput displays when its value is `null`.
         * For more information, refer to the article on
         * [placeholders]({% slug placeholders_dateinput %}).
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput placeholder="Enter birth date..."></kendo-dateinput>
         * `
         * })
         * export class AppComponent { }
         * ```
         */
        this.placeholder = null;
        /**
         * Configures the incremental steps of the DateInput.
         * For more information, refer to the article on
         * [incremental steps]({% slug incrementalsteps_dateinput %}).
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput [steps]="steps"></kendo-dateinput>
         * `
         * })
         * export class AppComponent {
         *   public steps = { year: 10, month: 1, day: 5 };
         * }
         * ```
         */
        this.steps = {
            // Default values are needed until fix in common package: https://github.com/telerik/kendo-dateinputs-common/issues/26
            second: 1,
            minute: 1,
            hour: 1,
            day: 1,
            month: 1,
            year: 1
        };
        /**
         * Determines whether the built-in min or max validators are to be enforced when a form is being validated.
         */
        this.rangeValidation = true;
        /**
         * @hidden
         *
         * Determines whether to auto correct invalid segments automatically.
         * TODO: To be fixed in common package before enabling: https://github.com/telerik/kendo-dateinputs-common/issues/24
         *
         * @default true
         */
        this.autoCorrectParts = true;
        /**
         * Determines whether to automatically move to the next segment after the user completes the current one.
         *
         * @default true
         */
        this.autoSwitchParts = true;
        /**
         * A string array representing custom keys, which will move the focus to the next date format segment.
         */
        this.autoSwitchKeys = [];
        /**
         * Determines if the users should see a blinking caret inside the Date Input when possible.
         *
         * @default false
         */
        this.allowCaretMode = false;
        /**
         * When enabled, the DateInput will autofill the rest of the date to the current date when the component loses focus.
         *
         * @default false
         */
        this.autoFill = false;
        /**
         * Determines whether the built-in validation for incomplete dates is to be enforced when a form is being validated.
         */
        this.incompleteDateValidation = false;
        /**
         * The maximum year to assume to be from the current century when typing two-digit year value
         * ([see example]({% slug formats_dateinput %}#toc-two-digit-year-format)).
         *
         * The default value is 68, indicating that typing any value less than 69
         * will be assumed to be 20xx, while 69 and larger will be assumed to be 19xx.
         */
        this.twoDigitYearMax = TWO_DIGIT_YEAR_MAX;
        /**
         * Indicates whether the mouse scroll can be used to increase/decrease the time segments values.
         *
         * @default true
         */
        this.enableMouseWheel = true;
        /**
         * Specifies whether the **Up** and **Down** spin buttons will be rendered.
         * For more information, refer to the article on
         * [spinner buttons]({% slug spinbuttons_dateinput %}).
         */
        this.spinners = false;
        /**
         * Fires each time the user selects a new value.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         */
        this.valueChange = new EventEmitter();
        /**
         * @hidden
         * Fires each time the user selects a new value.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         */
        this.valueUpdate = new EventEmitter();
        /**
         * Fires each time the user focuses the input element.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         *
         * > To wire the event programmatically, use the `onFocus` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput (focus)="handleFocus()"></kendo-dateinput>
         * `
         * })
         * export class AppComponent {
         *   public handleFocus(): void {
         *      console.log("Component is focused");
         *   }
         * }
         * ```
         *
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the input element gets blurred.
         * For more information, refer to the section on
         * [events]({% slug overview_dateinput %}#toc-events).
         *
         * > To wire the event programmatically, use the `onBlur` property.
         *
         * @example
         * ```ts
         * _@Component({
         * selector: 'my-app',
         * template: `
         *  <kendo-dateinput (blur)="handleBlur()"></kendo-dateinput>
         * `
         * })
         * export class AppComponent {
         *   public handleBlur(): void {
         *      console.log("Component is blurred");
         *   }
         * }
         * ```
         *
         */
        this.onBlur = new EventEmitter();
        this.arrow = Arrow;
        this.arrowDirection = Arrow.None;
        this.formatSections = { date: false, time: false };
        this.hasMousedown = false;
        this.focusedPriorToMousedown = false;
        /**
         * @hidden
         */
        this.isDateIncomplete = false;
        this.currentFormat = "";
        this.minValidator = noop;
        this.maxValidator = noop;
        this.incompleteValidator = noop;
        this._value = null;
        this._active = false;
        this._focusableId = `dateinput-${nextId++}`;
        this._formatPlaceholder = DEFAULT_FORMAT_PLACEHOLDER;
        this.kendoDate = null;
        this.kendoDateObject = null;
        this.domEvents = [];
        this.onControlChange = noop;
        this.onControlTouched = noop;
        this.onValidatorChange = noop;
        this._size = DEFAULT_SIZE;
        this._rounded = DEFAULT_ROUNDED;
        this._fillMode = DEFAULT_FILL_MODE;
        this.subs = new Subscription();
        validatePackage(packageMetadata);
        if (this.pickerService) {
            this.pickerService.input = this;
        }
        else {
            this.ariaReadOnly = null;
        }
    }
    /**
     * @hidden
     */
    set focusableId(_focusableId) {
        if (_focusableId) {
            this._focusableId = _focusableId;
        }
    }
    get focusableId() {
        return this._focusableId;
    }
    /**
     * @hidden
     */
    set pickerType(_pickerType) {
        if (_pickerType) {
            this.focusableId = `${_pickerType}-${nextId}`;
        }
    }
    ;
    /**
     * @hidden
     */
    set tabIndex(tabIndex) {
        this.tabindex = tabIndex;
    }
    get tabIndex() {
        return this.tabindex;
    }
    /**
     * Defines the descriptions of the format sections in the input field.
     * For more information, refer to the article on
     * [placeholders]({% slug placeholders_dateinput %}).
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     * <div class="row example-wrapper" [style.min-height.px]="450">
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Full-length format description:</p>
     *    <kendo-dateinput formatPlaceholder="wide"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Narrow-length format description:</p>
     *    <kendo-dateinput formatPlaceholder="narrow"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Short-length format description:</p>
     *    <kendo-dateinput formatPlaceholder="short"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Display defined format:</p>
     *    <kendo-dateinput format="MM/dd/yyyy" formatPlaceholder="formatPattern"></kendo-dateinput>
     *  </div>
     *
     *  <div class="col-xs-12 col-md-6 example-col">
     *    <p>Custom defined format descriptions</p>
     *    <kendo-dateinput format="G"
     *      [formatPlaceholder]="{
     *        year: 'y', month: 'M', day: 'd',
     *        hour: 'h', minute: 'm', second: 's'
     *      }"
     *    ></kendo-dateinput>
     *  </div>
     * </div>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    set formatPlaceholder(format) {
        this._formatPlaceholder = format ? format : DEFAULT_FORMAT_PLACEHOLDER;
    }
    get formatPlaceholder() {
        return this._formatPlaceholder;
    }
    /**
     * Specifies the value of the DateInput component.
     *
     * > The `value` has to be a valid [JavaScript `Date`](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Date) instance.
     */
    set value(value) {
        this.verifyValue(value);
        this._value = cloneDate(value);
        this.valueUpdate.emit(cloneDate(value));
    }
    get value() {
        return this._value;
    }
    /**
     * Sets the size of the component.
     *
     * The possible values are:
     * * `small`
     * * `medium` (Default)
     * * `large`
     * * `none`
     *
     */
    set size(size) {
        this.renderer.removeClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        const newSize = size ? size : DEFAULT_SIZE;
        if (newSize !== 'none') {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', newSize));
        }
        this._size = newSize;
    }
    get size() {
        return this._size;
    }
    /**
     * Sets the border radius of the component.
     *
     * The possible values are:
     * * `small`
     * * `medium` (Default)
     * * `large`
     * * `full`
     * * `none`
     *
     */
    set rounded(rounded) {
        this.renderer.removeClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        const newRounded = rounded ? rounded : DEFAULT_ROUNDED;
        if (newRounded !== 'none') {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(newRounded));
        }
        this._rounded = newRounded;
    }
    get rounded() {
        return this._rounded;
    }
    /**
     * Sets the fillMode of the component.
     *
     * The possible values are:
     * * `solid` (Default)
     * * `flat`
     * * `outline`
     * * `none`
     *
     */
    set fillMode(fillMode) {
        this.renderer.removeClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        const newFillMode = fillMode ? fillMode : DEFAULT_FILL_MODE;
        if (newFillMode !== 'none') {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', newFillMode));
            if (this.spinners && this.spinup && this.spindown) {
                this.setSpinnerFill(this.spinup.nativeElement, newFillMode, this.fillMode);
                this.setSpinnerFill(this.spindown.nativeElement, newFillMode, this.fillMode);
            }
        }
        this._fillMode = newFillMode;
    }
    get fillMode() {
        return this._fillMode;
    }
    get wrapperClass() {
        return true;
    }
    get disabledClass() {
        return this.disabled;
    }
    get inputElement() {
        return this.dateInput ? this.dateInput.nativeElement : null;
    }
    get inputValue() {
        return (this.inputElement || {}).value || '';
    }
    get isActive() {
        return this._active;
    }
    set isActive(value) {
        this._active = value;
        if (!this.wrapper) {
            return;
        }
        if (!isPresent(this.pickerService)) {
            const element = this.wrapper.nativeElement;
            if (value) {
                this.renderer.addClass(element, 'k-focus');
            }
            else {
                this.renderer.removeClass(element, 'k-focus');
            }
        }
    }
    /**
     * @hidden
     */
    get formControl() {
        const ngControl = this.injector.get(NgControl, null);
        return ngControl?.control || null;
    }
    get options() {
        return {
            format: this.format,
            steps: this.steps,
            readonly: this.readonly,
            formatPlaceholder: this.formatPlaceholder,
            placeholder: this.placeholder,
            autoCorrectParts: this.autoCorrectParts,
            autoSwitchParts: this.autoSwitchParts,
            selectPreviousSegmentOnBackspace: true,
            autoSwitchKeys: this.autoSwitchKeys,
            twoDigitYearMax: this.twoDigitYearMax,
            enableMouseWheel: this.enableMouseWheel,
            selectNearestSegmentOnFocus: false,
            allowCaretMode: this.allowCaretMode,
            autoFill: this.autoFill,
            value: this.value,
            intlService: new DateInputIntl(this.intl)
        };
    }
    /**
     * @hidden
     * Used by the TextBoxContainer to determine if the component is empty
     */
    isEmpty() {
        const currentValue = this.dateInput.nativeElement.value;
        return !currentValue || !String(currentValue).trim();
    }
    /**
     * @hidden
     */
    handleDragAndDrop(args) {
        args.preventDefault();
    }
    /**
     * @hidden
     */
    containsElement(element) {
        return Boolean(closest(element, node => node === this.wrapper.nativeElement));
    }
    /**
     * @hidden
     */
    ngOnInit() {
        if (this.kendoDate) {
            this.kendoDate.destroy();
        }
        this.kendoDate = this.initKendoDate();
        this.kendoDateObject = this.kendoDate.dateObject;
        this.updateFormatSections();
        this.subs.add(this.intl.changes.subscribe(this.intlChange.bind(this)));
        this.ngControl = this.injector.get(NgControl, null);
        if (this.wrapper) {
            this.renderer.removeAttribute(this.wrapper.nativeElement, 'tabindex');
        }
    }
    /**
     * @hidden
     */
    ngOnChanges(changes) {
        this.verifyRange();
        if (changes['min'] || changes['max'] || changes['rangeValidation'] || changes['incompleteDateValidation']) {
            this.minValidator = this.rangeValidation ? minValidator(this.min) : noop;
            this.maxValidator = this.rangeValidation ? maxValidator(this.max) : noop;
            this.incompleteValidator = this.incompleteDateValidation ? incompleteDateValidator() : noop;
            this.onValidatorChange();
        }
        const isEqualToKendoDate = this.kendoDate && isEqual(this.value, this.kendoDate.value);
        if (changes['format'] || !isEqualToKendoDate || changes['placeholder']) {
            if (!this.kendoDate) {
                return;
            }
            ;
            this.kendoDate?.setOptions(this.options, true);
            this.updateFormatSections();
        }
    }
    updateFormatSections() {
        this.formatSections = this.intl.splitDateFormat(this.kendoDate.inputFormat)
            .reduce(({ date, time }, p) => {
            return {
                date: date || DATE_PART_REGEXP.test(p.type),
                time: time || TIME_PART_REGEXP.test(p.type)
            };
        }, { date: false, time: false });
    }
    updateIncompleteValidationStatus() {
        const previousValue = this.isDateIncomplete;
        this.isDateIncomplete = this.kendoDateObject.hasValue() && this.value === null;
        if (previousValue === this.isDateIncomplete || !this.incompleteDateValidation) {
            return;
        }
        if (isPresent(this.ngControl) && !isPresent(this.pickerService)) {
            this.cdr.markForCheck();
            this.ngZone.run(() => this.onValidatorChange());
        }
        else if (isPresent(this.pickerService)) {
            this.pickerService.dateCompletenessChange.emit();
        }
    }
    ngAfterViewInit() {
        this.setComponentClasses();
        const formControl = this.injector.get(NgControl, null)?.control;
        this.control = formControl;
        this.subs.add(this.formControl?.statusChanges.subscribe(() => this.setAriaInvalid()));
        this.setAriaInvalid();
    }
    ngOnDestroy() {
        this.subs.unsubscribe();
        if (this.pickerService) {
            this.pickerService.input = null;
        }
        this.domEvents.forEach(unbindCallback => unbindCallback());
    }
    /**
     * @hidden
     */
    setAriaInvalid() {
        if (!this.control) {
            return;
        }
        if (this.control.invalid) {
            this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, 'true');
        }
        else {
            this.renderer.setAttribute(this.inputElement, attributeNames.ariaInvalid, 'false');
        }
    }
    /**
     * @hidden
     */
    validate(control) {
        return this.minValidator(control) || this.maxValidator(control) || this.incompleteValidator(control, this.isDateIncomplete);
    }
    /**
     * @hidden
     */
    registerOnValidatorChange(fn) {
        this.onValidatorChange = fn;
    }
    /**
     * @hidden
     */
    setDisabledState(isDisabled) {
        this.disabled = isDisabled;
        this.cdr.markForCheck();
    }
    //ngModel binding
    /**
     * @hidden
     */
    writeValue(value) {
        this.verifyValue(value);
        this.value = cloneDate(value);
        this.kendoDate?.setOptions(this.options, true);
        this.kendoDateObject?.setValue(this.value);
        this.kendoDate?.refreshElementValue();
    }
    /**
     * @hidden
     */
    triggerChange() {
        const value = this.kendoDate.value;
        if (+value !== +this.value) {
            this.value = cloneDate(value);
            this.notify();
        }
    }
    /**
     * @hidden
     */
    notify() {
        this.ngZone.run(() => {
            this.onControlChange(cloneDate(this.value));
            this.valueChange.emit(cloneDate(this.value));
        });
    }
    /**
     * @hidden
     */
    registerOnChange(fn) {
        this.onControlChange = fn;
    }
    /**
     * @hidden
     */
    registerOnTouched(fn) {
        this.onControlTouched = fn;
    }
    /**
     * Focuses the DateInput component.
     *
     * @example
     * ```ts
     * _@Component({
     * selector: 'my-app',
     * template: `
     *  <button (click)="dateinput.focus()">Focus date input</button>
     *  <kendo-dateinput #dateinput></kendo-dateinput>
     * `
     * })
     * export class AppComponent { }
     * ```
     */
    focus() {
        this.kendoDate && this.kendoDate.focus();
    }
    /**
     * Blurs the DateInput component.
     */
    blur() {
        const input = this.inputElement;
        if (input) {
            input.blur();
        }
    }
    /**
     * @hidden
     */
    handleButtonClick(offset) {
        this.arrowDirection = Arrow.None;
        this.kendoDate.focus();
        this.kendoDate.modifyDateSegmentValue(offset);
    }
    initKendoDate() {
        const kendoDate = new DateInput(this.dateInput.nativeElement, {
            ...this.options,
            events: {
                valueChange: this.onWidgetValueChange.bind(this),
                inputEnd: this.onWidgetInputEnd.bind(this),
                focusEnd: this.onWidgetFocus.bind(this),
                blurEnd: this.onWidgetBlur.bind(this),
                keydown: this.onWidgetKeyDown.bind(this),
            }
        });
        return kendoDate;
    }
    onWidgetValueChange() {
        this.triggerChange();
    }
    onWidgetKeyDown() {
        this.kendoDateObject = this.kendoDate.dateObject;
    }
    onWidgetInputEnd() {
        this.updateIncompleteValidationStatus();
    }
    onWidgetFocus({ event: FocuseEvent }) {
        this.isActive = true;
        if (hasObservers(this.onFocus)) {
            this.ngZone.run(() => {
                this.emitFocus(event);
            });
        }
        else {
            this.emitFocus(event);
        }
    }
    onWidgetBlur({ event: FocuseEvent }) {
        this.isActive = false;
        if (hasObservers(this.onBlur) || requiresZoneOnBlur(this.ngControl)) {
            this.ngZone.run(() => {
                this.onControlTouched();
                this.emitBlur(event);
                this.cdr.markForCheck();
            });
        }
        else {
            this.emitBlur(event);
        }
    }
    verifyRange() {
        if (!isDevMode()) {
            return;
        }
        if (!isValidRange(this.min, this.max)) {
            throw new Error(`The max value should be bigger than the min. See ${MIN_DOC_LINK} and ${MAX_DOC_LINK}.`);
        }
    }
    verifyValue(value) {
        if (!isDevMode()) {
            return;
        }
        if (value && !(value instanceof Date)) {
            throw new Error(`The 'value' should be a valid JavaScript Date instance. Check ${VALUE_DOC_LINK} for possible resolution.`);
        }
    }
    intlChange() {
        this.kendoDate.setOptions(this.options, true);
        this.updateFormatSections();
    }
    emitFocus(args) {
        this.onFocus.emit();
        if (this.pickerService) {
            this.pickerService.onFocus.emit(args);
        }
    }
    emitBlur(args) {
        this.onBlur.emit();
        if (this.pickerService) {
            this.pickerService.onBlur.emit(args);
        }
    }
    setSpinnerFill(spinner, fill, oldFill) {
        if (oldFill !== 'none') {
            this.renderer.removeClass(spinner, `k-button-${oldFill}`);
            this.renderer.removeClass(spinner, `k-button-${oldFill}-base`);
        }
        this.renderer.addClass(spinner, `k-button-${fill}`);
        this.renderer.addClass(spinner, `k-button-${fill}-base`);
    }
    setComponentClasses() {
        if (this.size !== 'none') {
            this.renderer.addClass(this.wrapper.nativeElement, getSizeClass('input', this.size));
        }
        if (this.rounded !== 'none') {
            this.renderer.addClass(this.wrapper.nativeElement, getRoundedClass(this.rounded));
        }
        if (this.fillMode !== 'none') {
            this.renderer.addClass(this.wrapper.nativeElement, getFillModeClass('input', this.fillMode));
        }
        if (this.spinners && this.fillMode !== 'none') {
            this.setSpinnerFill(this.spinup.nativeElement, this.fillMode);
            this.setSpinnerFill(this.spindown.nativeElement, this.fillMode);
        }
    }
}
DateInputComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DateInputComponent, deps: [{ token: i0.ChangeDetectorRef }, { token: i1.IntlService }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i0.NgZone }, { token: i0.Injector }, { token: i2.LocalizationService }, { token: i3.PickerService, optional: true }], target: i0.ɵɵFactoryTarget.Component });
DateInputComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: DateInputComponent, selector: "kendo-dateinput", inputs: { focusableId: "focusableId", pickerType: "pickerType", disabled: "disabled", readonly: "readonly", title: "title", tabindex: "tabindex", role: "role", ariaReadOnly: "ariaReadOnly", tabIndex: "tabIndex", format: "format", formatPlaceholder: "formatPlaceholder", placeholder: "placeholder", steps: "steps", max: "max", min: "min", rangeValidation: "rangeValidation", autoCorrectParts: "autoCorrectParts", autoSwitchParts: "autoSwitchParts", autoSwitchKeys: "autoSwitchKeys", allowCaretMode: "allowCaretMode", autoFill: "autoFill", incompleteDateValidation: "incompleteDateValidation", twoDigitYearMax: "twoDigitYearMax", enableMouseWheel: "enableMouseWheel", value: "value", spinners: "spinners", isPopupOpen: "isPopupOpen", hasPopup: "hasPopup", size: "size", rounded: "rounded", fillMode: "fillMode" }, outputs: { valueChange: "valueChange", valueUpdate: "valueUpdate", onFocus: "focus", onBlur: "blur" }, host: { properties: { "class.k-input": "this.wrapperClass", "class.k-dateinput": "this.wrapperClass", "class.k-disabled": "this.disabledClass" } }, providers: [
        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateInputComponent), multi: true },
        { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateInputComponent), multi: true },
        { provide: L10N_PREFIX, useValue: 'kendo.dateinput' },
        { provide: KendoInput, useExisting: forwardRef(() => DateInputComponent) },
        LocalizationService
    ], viewQueries: [{ propertyName: "dateInput", first: true, predicate: ["dateInput"], descendants: true, static: true }, { propertyName: "spinup", first: true, predicate: ["spinup"], descendants: true }, { propertyName: "spindown", first: true, predicate: ["spindown"], descendants: true }], exportAs: ["kendo-dateinput"], usesOnChanges: true, ngImport: i0, template: `
    <ng-container kendoDateInputLocalizedMessages
        i18n-increment="kendo.dateinput.increment|The label for the **Increment** button in the DateInput"
        increment="Increase value"

        i18n-decrement="kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput"
        decrement="Decrease value"
    >
    </ng-container>
    <input
        #dateInput
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        class="k-input-inner"
        [attr.role]="role"
        [attr.aria-readonly]="ariaReadOnly"
        [id]="focusableId"
        [title]="title"
        [tabindex]="tabindex"
        [disabled]="disabled"
        [readonly]="readonly"
        [placeholder]="placeholder"
        [attr.aria-expanded]="isPopupOpen"
        [attr.aria-haspopup]="hasPopup"
        [kendoEventsOutsideAngular]="{
            dragstart: handleDragAndDrop,
            drop: handleDragAndDrop
        }"
        [scope]="this"
        />
    <span *ngIf="spinners" class="k-input-spinner k-spin-button" (mousedown)="$event.preventDefault()">
        <button
            #spinup
            tabindex="-1"
            class="k-spinner-increase k-button k-icon-button"
            [class.k-active]="arrowDirection === arrow.Up"
            (mousedown)="arrowDirection = arrow.Up"
            (mouseleave)="arrowDirection = arrow.None"
            (click)="handleButtonClick(1)"
            [title]="localization.get('increment')"
            [attr.aria-label]="localization.get('increment')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-up"
                    [svgIcon]="caretAltUpIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
        <button
            #spindown
            tabindex="-1"
            class="k-spinner-decrease k-button k-icon-button"
            (click)="handleButtonClick(-1)"
            [class.k-active]="arrowDirection === arrow.Down"
            (mousedown)="arrowDirection = arrow.Down"
            (mouseleave)="arrowDirection = arrow.None"
            [title]="localization.get('decrement')"
            [attr.aria-label]="localization.get('decrement')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-down"
                    [svgIcon]="caretAltDownIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
    </span>
  `, isInline: true, components: [{ type: i4.IconWrapperComponent, selector: "kendo-icon-wrapper", inputs: ["name", "svgIcon", "innerCssClass", "customFontClass", "size"], exportAs: ["kendoIconWrapper"] }], directives: [{ type: i5.DateInputLocalizedMessagesDirective, selector: "[kendoDateInputLocalizedMessages]" }, { type: i6.EventsOutsideAngularDirective, selector: "[kendoEventsOutsideAngular]", inputs: ["kendoEventsOutsideAngular", "scope"] }, { type: i7.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DateInputComponent, decorators: [{
            type: Component,
            args: [{
                    changeDetection: ChangeDetectionStrategy.OnPush,
                    exportAs: 'kendo-dateinput',
                    providers: [
                        { provide: NG_VALUE_ACCESSOR, useExisting: forwardRef(() => DateInputComponent), multi: true },
                        { provide: NG_VALIDATORS, useExisting: forwardRef(() => DateInputComponent), multi: true },
                        { provide: L10N_PREFIX, useValue: 'kendo.dateinput' },
                        { provide: KendoInput, useExisting: forwardRef(() => DateInputComponent) },
                        LocalizationService
                    ],
                    selector: 'kendo-dateinput',
                    template: `
    <ng-container kendoDateInputLocalizedMessages
        i18n-increment="kendo.dateinput.increment|The label for the **Increment** button in the DateInput"
        increment="Increase value"

        i18n-decrement="kendo.dateinput.decrement|The label for the **Decrement** button in the DateInput"
        decrement="Decrease value"
    >
    </ng-container>
    <input
        #dateInput
        autocomplete="off"
        autocorrect="off"
        autocapitalize="off"
        spellcheck="false"
        class="k-input-inner"
        [attr.role]="role"
        [attr.aria-readonly]="ariaReadOnly"
        [id]="focusableId"
        [title]="title"
        [tabindex]="tabindex"
        [disabled]="disabled"
        [readonly]="readonly"
        [placeholder]="placeholder"
        [attr.aria-expanded]="isPopupOpen"
        [attr.aria-haspopup]="hasPopup"
        [kendoEventsOutsideAngular]="{
            dragstart: handleDragAndDrop,
            drop: handleDragAndDrop
        }"
        [scope]="this"
        />
    <span *ngIf="spinners" class="k-input-spinner k-spin-button" (mousedown)="$event.preventDefault()">
        <button
            #spinup
            tabindex="-1"
            class="k-spinner-increase k-button k-icon-button"
            [class.k-active]="arrowDirection === arrow.Up"
            (mousedown)="arrowDirection = arrow.Up"
            (mouseleave)="arrowDirection = arrow.None"
            (click)="handleButtonClick(1)"
            [title]="localization.get('increment')"
            [attr.aria-label]="localization.get('increment')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-up"
                    [svgIcon]="caretAltUpIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
        <button
            #spindown
            tabindex="-1"
            class="k-spinner-decrease k-button k-icon-button"
            (click)="handleButtonClick(-1)"
            [class.k-active]="arrowDirection === arrow.Down"
            (mousedown)="arrowDirection = arrow.Down"
            (mouseleave)="arrowDirection = arrow.None"
            [title]="localization.get('decrement')"
            [attr.aria-label]="localization.get('decrement')"
            >
                <kendo-icon-wrapper
                    name="caret-alt-down"
                    [svgIcon]="caretAltDownIcon"
                    innerCssClass="k-button-icon"
                >
                </kendo-icon-wrapper>
        </button>
    </span>
  `
                }]
        }], ctorParameters: function () { return [{ type: i0.ChangeDetectorRef }, { type: i1.IntlService }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i0.NgZone }, { type: i0.Injector }, { type: i2.LocalizationService }, { type: i3.PickerService, decorators: [{
                    type: Optional
                }] }]; }, propDecorators: { focusableId: [{
                type: Input
            }], pickerType: [{
                type: Input
            }], disabled: [{
                type: Input
            }], readonly: [{
                type: Input
            }], title: [{
                type: Input
            }], tabindex: [{
                type: Input
            }], role: [{
                type: Input
            }], ariaReadOnly: [{
                type: Input
            }], tabIndex: [{
                type: Input
            }], format: [{
                type: Input
            }], formatPlaceholder: [{
                type: Input
            }], placeholder: [{
                type: Input
            }], steps: [{
                type: Input
            }], max: [{
                type: Input
            }], min: [{
                type: Input
            }], rangeValidation: [{
                type: Input
            }], autoCorrectParts: [{
                type: Input
            }], autoSwitchParts: [{
                type: Input
            }], autoSwitchKeys: [{
                type: Input
            }], allowCaretMode: [{
                type: Input
            }], autoFill: [{
                type: Input
            }], incompleteDateValidation: [{
                type: Input
            }], twoDigitYearMax: [{
                type: Input
            }], enableMouseWheel: [{
                type: Input
            }], value: [{
                type: Input
            }], spinners: [{
                type: Input
            }], isPopupOpen: [{
                type: Input
            }], hasPopup: [{
                type: Input
            }], size: [{
                type: Input
            }], rounded: [{
                type: Input
            }], fillMode: [{
                type: Input
            }], valueChange: [{
                type: Output
            }], valueUpdate: [{
                type: Output
            }], onFocus: [{
                type: Output,
                args: ['focus']
            }], onBlur: [{
                type: Output,
                args: ['blur']
            }], dateInput: [{
                type: ViewChild,
                args: ['dateInput', { static: true }]
            }], wrapperClass: [{
                type: HostBinding,
                args: ['class.k-input']
            }, {
                type: HostBinding,
                args: ['class.k-dateinput']
            }], disabledClass: [{
                type: HostBinding,
                args: ['class.k-disabled']
            }], spinup: [{
                type: ViewChild,
                args: ['spinup', { static: false }]
            }], spindown: [{
                type: ViewChild,
                args: ['spindown', { static: false }]
            }] } });

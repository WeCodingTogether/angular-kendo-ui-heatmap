/**-----------------------------------------------------------------------------------------
* Copyright © 2023 Progress Software Corporation. All rights reserved.
* Licensed under commercial license. See LICENSE.md in the project root for more information
*-------------------------------------------------------------------------------------------*/
import { Component, ContentChild, ContentChildren, ChangeDetectorRef, ElementRef, EventEmitter, TemplateRef, NgZone, Input, Output, ViewChild, ViewChildren, ViewContainerRef, Inject, QueryList, Optional, Renderer2 } from '@angular/core';
import { L10N_PREFIX, LocalizationService, RTL } from '@progress/kendo-angular-l10n';
import { PopupService } from '@progress/kendo-angular-popup';
import { DateRangePopupTemplateDirective } from './date-range-popup-template.directive';
import { DateRangeService } from './date-range.service';
import { MultiViewCalendarComponent } from '../calendar/multiview-calendar.component';
import { PreventableEvent } from '../preventable-event';
import { isDocumentAvailable, guid, Keys, hasObservers } from '@progress/kendo-angular-common';
import { Subscription, fromEvent, merge } from 'rxjs';
import { filter, map } from 'rxjs/operators';
import { isWindowAvailable, windowSize } from '../util';
import { isPresent } from '../common/utils';
import { xIcon } from '@progress/kendo-svg-icons';
import { DateRangeSelectionDirective } from './date-range-selection.directive';
import { ActionSheetComponent } from '@progress/kendo-angular-navigation';
import * as i0 from "@angular/core";
import * as i1 from "@progress/kendo-angular-popup";
import * as i2 from "./date-range.service";
import * as i3 from "@progress/kendo-angular-l10n";
import * as i4 from "../calendar/multiview-calendar.component";
import * as i5 from "@progress/kendo-angular-navigation";
import * as i6 from "@progress/kendo-angular-common";
import * as i7 from "@progress/kendo-angular-buttons";
import * as i8 from "./localization/daterange-popup-localized-messages.directive";
import * as i9 from "./date-range-selection.directive";
import * as i10 from "@angular/common";
/**
 * Represents the Kendo UI DateRangePopup component for Angular.
 *
 * @example
 * ```ts
 * import { DateInputsModule, DateRangeService } from '@progress/kendo-angular-dateinputs';
 *
 * _@Component({
 * providers: [DateRangeService],
 * selector: 'my-app',
 * template: `
 *  <button #anchor (click)="popup.toggle()">Toggle</button>
 *  <kendo-daterange-popup [anchor]="anchor" #popup></kendo-daterange-popup>
 * `
 * })
 * export class AppComponent {
 * }
 * ```
 */
export class DateRangePopupComponent {
    constructor(popupService, dateRangeService, zone, renderer, localization, cdr, rtl) {
        this.popupService = popupService;
        this.dateRangeService = dateRangeService;
        this.zone = zone;
        this.renderer = renderer;
        this.localization = localization;
        this.cdr = cdr;
        this.rtl = rtl;
        /**
         * Controls the popup animation.
         * By default, the opening and closing animations are enabled.
         * For more information about controlling the popup animations,
         * refer to the article on [animations]({% slug animations_popup %}).
         */
        this.animate = true;
        /**
         * Configures the collision behavior of the popup.
         * For more information, refer to the article on
         * [viewport boundary detection]({% slug viewportboundarydetection_popup %}).
         */
        this.collision = { horizontal: 'fit', vertical: 'flip' };
        /**
         * Enables or disables the adaptive mode. By default the adaptive rendering is disabled.
         */
        this.adaptiveMode = 'none';
        /**
         * Sets the title of the input element of the DateRangePopup and the title text rendered
         * in the header of the popup(action sheet). Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
         */
        this.title = "";
        /**
         * Fires each time the popup is about to open.
         * This event is preventable. If you cancel the event, the popup will remain closed.
         * For more information, refer to the section on
         * [events]({% slug overview_datepicker %}#toc-events).
         */
        this.open = new EventEmitter();
        /**
         * Fires each time the popup is about to close.
         * This event is preventable. If you cancel the event, the popup will remain open.
         * For more information, refer to the section on
         * [events]({% slug overview_datepicker %}#toc-events).
         */
        this.close = new EventEmitter();
        /**
         * Fires each time the calendar element is blurred.
         */
        this.onBlur = new EventEmitter();
        /**
         * Fires each time the calendar element is focused.
         */
        this.onFocus = new EventEmitter();
        /**
         * Fires each time the popup is closed either on `ESC` keypress or on leaving the viewport.
         */
        this.cancel = new EventEmitter();
        /**
         * @hidden
         */
        this.popupUID = guid();
        /**
         * @hidden
         */
        this.xIcon = xIcon;
        this.calendarSubscriptions = new Subscription();
        this.popupSubscriptions = new Subscription();
        this.localizationSubscriptions = new Subscription();
        this.resolvedPromise = Promise.resolve();
    }
    /**
     * Sets the subtitle text rendered in the header of the popup(action sheet).
     * Applicable only when [`AdaptiveMode` is set to `auto`](slug:api_dateinputs_adaptivemode).
     */
    set subtitle(subtitle) {
        this._subtitle = subtitle;
    }
    get subtitle() {
        return this._subtitle;
    }
    /**
     * The active calendar that is visible in the popup.
     *
     * > When the popup is closed, the property returns `null`.
     */
    get calendar() {
        return this._calendar;
    }
    set calendar(calendar) {
        this._calendar = calendar;
        this.subscribeFocusBlur(calendar);
    }
    /**
     * Gets the active state of the component.
     * When the opened calendar is active, returns `true`.
     */
    get isActive() {
        // The actionsheet is expanding before the calendar gets activated
        // and if we only check for calendar.isActive a blur event handler in the date-rage-input.ts will close the actionsheet
        // TODO: Potentially the entire logic would need refactoring to avoid hacks like this one
        return (this.calendar && this.calendar.isActive)
            || (this.actionSheet && this.actionSheet.expanded);
    }
    /**
     * @hidden
     */
    get isAdaptiveModeEnabled() {
        return this.adaptiveMode === 'auto';
    }
    /**
     * @hidden
     */
    get isAdaptive() {
        return this.isAdaptiveModeEnabled && this.windowSize !== 'large';
    }
    /**
     * Gets or sets the visibility state of the component.
     */
    set show(show) {
        if (this._show === show) {
            return;
        }
        const event = new PreventableEvent();
        if (show) {
            this.open.emit(event);
        }
        else {
            this.close.emit(event);
        }
        if (event.isDefaultPrevented()) {
            return;
        }
        this.toggleDateRange(show);
    }
    get show() {
        return this._show;
    }
    ngOnInit() {
        this.dateRangeService.registerPopup(this);
        if (this.localization) {
            this.localizationSubscriptions.add(this.localization
                .changes
                .subscribe(() => this.cdr.markForCheck()));
        }
    }
    ngAfterViewInit() {
        this.calendarSubscriptions.add(this.contentCalendar.changes.subscribe((changes) => {
            this.calendar = changes.first;
            this.actionSheet.titleId = changes.first?.headerId;
            this.cdr.detectChanges();
        }));
        this.calendarSubscriptions.add(this.viewCalendar.changes.subscribe((changes) => {
            this.calendar = changes.first;
            this.actionSheet.titleId = changes.first?.headerId;
            this.cdr.detectChanges();
        }));
        if (isWindowAvailable()) {
            this.zone.runOutsideAngular(() => this.windowBlurSubscription = fromEvent(window, 'blur').subscribe(this.handleWindowBlur.bind(this)));
        }
        if (this.actionSheet && isDocumentAvailable()) {
            // The following syntax is used as it does not violate CSP compliance
            this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-height', '60vh');
            this.actionSheet.element.nativeElement.style.setProperty('--kendo-actionsheet-max-height', 'none');
        }
    }
    ngOnDestroy() {
        this.destroyPopup();
        this.calendarSubscriptions.unsubscribe();
        if (this.activateSubscription) {
            this.activateSubscription.unsubscribe();
        }
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
            this.focusSubscription.unsubscribe();
        }
        if (this.windowBlurSubscription) {
            this.windowBlurSubscription.unsubscribe();
        }
    }
    /**
     *  Opens the popup component and focuses the calendar.
     */
    activate() {
        if (this.show === true) {
            return;
        }
        if (this.activateSubscription) {
            this.activateSubscription.unsubscribe();
        }
        this.show = true;
        this.cdr.markForCheck();
        this.zone.runOutsideAngular(() => {
            this.activateSubscription = merge(this.contentCalendar.changes, this.viewCalendar.changes)
                .pipe(filter(changes => changes && changes.first), map(changes => changes.first))
                .subscribe((calendar) => setTimeout(() => {
                calendar.focus();
                this.calendarSubscriptions.add(calendar.viewList.focusedCellChange.subscribe((id) => {
                    this.dateRangeService.setActiveDescendent(id);
                }));
            }));
        });
    }
    /**
     *  Focuses the calendar (if available).
     */
    focus() {
        if (this.calendar) {
            this.calendar.focus();
        }
    }
    /**
     * Checks if a focused element ids placed inside the popup.
     *
     * @return boolean;
     */
    hasActiveContent() {
        if (!isDocumentAvailable() || !this.popupRef) {
            return false;
        }
        return this.popupRef.popupElement.contains(document.activeElement);
    }
    /**
     * Toggles the visibility of the popup or actionSheet.
     * If you use the `toggle` method to show or hide the popup or actionSheet,
     * the `open` and `close` events do not fire.
     *
     * @param show The state of the popup.
     */
    toggle(show) {
        this.resolvedPromise.then(() => {
            this.toggleDateRange((show === undefined) ? !this.show : show);
        });
    }
    /**
     * @hidden
     *
     * Closes the popup and triggers the `cancel` event.
     */
    cancelPopup() {
        this.show = false;
        this.cancel.emit();
    }
    /**
     * @hidden
     */
    handleAccept() {
        this.dateRangeSelectionDirective.setRange(this.dateRangeService.selectionRange);
        this.show = false;
    }
    /**
     * @hidden
     */
    onResize() {
        if (!this.show || this.windowSize === windowSize()) {
            return;
        }
        ;
        if (this.actionSheet.expanded) {
            this.toggleActionSheet(false);
        }
        else {
            this.togglePopup(false);
        }
        this.windowSize = windowSize();
    }
    /**
     * @hidden
     */
    closePopup(event) {
        event.preventDefault();
        event.stopPropagation();
        this.toggle(false);
        if (this.dateRangeService.activeRangeEnd === 'start' || !this.dateRangeService.activeRangeEnd) {
            this.dateRangeService.startInput$.value.focus();
        }
        else {
            this.dateRangeService.endInput$.value.focus();
        }
        ;
    }
    /**
     * @hidden
     */
    handleTab(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.dateRangeService.activeRangeEnd === 'start' || !this.dateRangeService.activeRangeEnd) {
            this.dateRangeService.setActiveRangeEnd('end');
        }
        else {
            this.dateRangeService.endInput$.value.focus();
        }
    }
    ;
    /**
     * @hidden
     */
    handleShiftTab(event) {
        event.preventDefault();
        event.stopPropagation();
        if (this.dateRangeService.activeRangeEnd === 'end') {
            this.dateRangeService.setActiveRangeEnd('start');
        }
        else {
            this.dateRangeService.startInput$.value.focus();
        }
    }
    handleWindowBlur() {
        if (!this.show || this.actionSheet.expanded) {
            return;
        }
        if (hasObservers(this.close)) {
            this.zone.run(() => this.show = false);
        }
        else {
            this.show = false;
        }
    }
    handleMouseLeave() {
        this.dateRangeService.setRange(this.dateRangeService.selectionRange);
    }
    handleKeydown(event) {
        const { altKey, keyCode } = event;
        if (keyCode === Keys.Escape || (altKey && keyCode === Keys.ArrowUp)) {
            this.zone.run(() => this.cancelPopup());
        }
    }
    subscribeFocusBlur(calendar) {
        if (this.blurSubscription) {
            this.blurSubscription.unsubscribe();
            this.focusSubscription.unsubscribe();
        }
        if (!calendar) {
            return;
        }
        const calendarElement = calendar.element.nativeElement.querySelector('.k-calendar-view');
        this.blurSubscription = fromEvent(calendarElement, 'blur').subscribe(() => this.onBlur.emit());
        this.focusSubscription = fromEvent(calendarElement, 'focus').subscribe(() => this.onFocus.emit());
    }
    addPopupSubscriptions(...subscriptions) {
        if (!isPresent(this.popupSubscriptions)) {
            this.popupSubscriptions = new Subscription();
        }
        subscriptions.map(s => this.popupSubscriptions.add(s));
    }
    get _appendTo() {
        const appendTo = this.appendTo;
        if (!appendTo || appendTo === 'root') {
            return undefined;
        }
        return appendTo === 'component' ? this.container : appendTo;
    }
    togglePopup(show) {
        this._show = show;
        if (this.popupRef) {
            this.destroyPopup();
        }
        if (this._show) {
            const direction = this.rtl ? 'right' : 'left';
            this.popupRef = this.popupService.open({
                anchor: this.anchor,
                anchorAlign: this.anchorAlign || { vertical: 'bottom', horizontal: direction },
                animate: this.animate,
                appendTo: this._appendTo,
                collision: this.collision,
                content: (this.contentTemplate || {}).templateRef || this.defaultTemplate,
                margin: this.margin,
                popupAlign: this.popupAlign || { vertical: 'top', horizontal: direction },
                positionMode: 'absolute'
            });
            const { popupElement, popupAnchorViewportLeave } = this.popupRef;
            popupElement.setAttribute('id', this.popupUID);
            this.addPopupSubscriptions(this.zone.runOutsideAngular(() => fromEvent(popupElement, 'keydown').subscribe(this.handleKeydown.bind(this))), fromEvent(popupElement, 'mouseleave').subscribe(this.handleMouseLeave.bind(this)), popupAnchorViewportLeave.subscribe(() => this.cancelPopup()));
        }
    }
    destroyPopup() {
        if (isPresent(this.popupRef)) {
            this.popupRef.close();
            this.popupRef = null;
        }
        if (isPresent(this.popupSubscriptions)) {
            this.popupSubscriptions.unsubscribe();
        }
    }
    toggleDateRange(show) {
        this.windowSize = windowSize();
        if (this.isAdaptive) {
            this.toggleActionSheet(show);
        }
        else {
            this.togglePopup(show);
        }
    }
    toggleActionSheet(show) {
        if (show === this._show) {
            return;
        }
        if (show && !this.actionSheet.expanded) {
            this.actionSheet.toggle();
            this.updateActionSheetAdaptiveAppearance();
            this.renderer.setAttribute(this.actionSheet.element.nativeElement, 'id', this.popupUID);
        }
        else if (!show && this.actionSheet.expanded) {
            this.actionSheet.toggle();
        }
        this._show = show;
    }
    updateActionSheetAdaptiveAppearance() {
        let element;
        let animationContainer;
        if (this.actionSheet) {
            element = this.actionSheet['element'].nativeElement.querySelector('.k-actionsheet');
            animationContainer = this.actionSheet['element'].nativeElement.querySelector('.k-child-animation-container');
            if (this.windowSize === 'medium') {
                this.renderer.removeClass(element, 'k-actionsheet-fullscreen');
                this.renderer.removeStyle(animationContainer, 'height');
            }
            else if (this.windowSize === 'small') {
                this.renderer.addClass(element, 'k-actionsheet-fullscreen');
                this.renderer.setStyle(animationContainer, 'height', '100%');
            }
            this.renderer.addClass(element, 'k-adaptive-actionsheet');
            this.renderer.addClass(element, 'k-actionsheet-bottom');
            this.renderer.setStyle(animationContainer, 'bottom', '0px');
        }
    }
}
DateRangePopupComponent.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DateRangePopupComponent, deps: [{ token: i1.PopupService }, { token: i2.DateRangeService }, { token: i0.NgZone }, { token: i0.Renderer2 }, { token: i3.LocalizationService }, { token: i0.ChangeDetectorRef }, { token: RTL, optional: true }], target: i0.ɵɵFactoryTarget.Component });
DateRangePopupComponent.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "12.0.0", version: "13.3.12", type: DateRangePopupComponent, selector: "kendo-daterange-popup", inputs: { animate: "animate", anchor: "anchor", anchorAlign: "anchorAlign", appendTo: "appendTo", collision: "collision", popupAlign: "popupAlign", margin: "margin", adaptiveMode: "adaptiveMode", title: "title", subtitle: "subtitle" }, outputs: { open: "open", close: "close", onBlur: "blur", onFocus: "focus", cancel: "cancel" }, providers: [
        LocalizationService,
        {
            provide: L10N_PREFIX,
            useValue: 'kendo.daterangepopup'
        }
    ], queries: [{ propertyName: "contentTemplate", first: true, predicate: DateRangePopupTemplateDirective, descendants: true }, { propertyName: "contentCalendar", predicate: MultiViewCalendarComponent }], viewQueries: [{ propertyName: "container", first: true, predicate: ["container"], descendants: true, read: ViewContainerRef }, { propertyName: "actionSheet", first: true, predicate: ["actionSheet"], descendants: true }, { propertyName: "defaultTemplate", first: true, predicate: ["defaultTemplate"], descendants: true }, { propertyName: "dateRangeSelectionDirective", first: true, predicate: DateRangeSelectionDirective, descendants: true }, { propertyName: "viewCalendar", predicate: MultiViewCalendarComponent, descendants: true }], exportAs: ["kendo-daterange-popup"], ngImport: i0, template: `
        <ng-container kendoDateRangePopupLocalizedMessages
            i18n-accept="kendo.daterangepopup.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.daterangepopup.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"
        >
        </ng-container> 
        <ng-container #container></ng-container>
        <ng-template #defaultTemplate>
            <kendo-multiviewcalendar kendoDateRangeSelection (onClosePopup)="closePopup($event)" (onTabPress)="handleTab($event)" (onShiftTabPress)="handleShiftTab($event)"></kendo-multiviewcalendar>
        </ng-template>

        <kendo-actionsheet
            #actionSheet
            (overlayClick)="show=false"
            (collapse)="onBlur.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <!-- Resize sensor needs to be inside the template because the date-range-popup
                element itself always has 0x0 size and does not trigger the sensor. 
                Note: The popup in non-adaptive mode closes on window blur -->
                <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="x"
                                [attr.title]="localization.get('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <div class="k-scrollable-wrap">
                        <kendo-multiviewcalendar
                            class="k-calendar-lg"
                            orientation="vertical"
                            kendoDateRangeSelection
                            [shouldSetRange]="false">
                        </kendo-multiviewcalendar>
                    </div>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton 
                        type="button"
                        size="large"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        (click)="show=false"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        size="large"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        (click)="handleAccept()"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `, isInline: true, components: [{ type: i4.MultiViewCalendarComponent, selector: "kendo-multiviewcalendar", inputs: ["id", "focusedDate", "min", "max", "rangeValidation", "disabledDatesRangeValidation", "selection", "value", "disabled", "tabindex", "tabIndex", "isActive", "disabledDates", "activeView", "bottomView", "topView", "showViewHeader", "animateNavigation", "weekNumber", "activeRangeEnd", "selectionRange", "views", "orientation", "cellTemplate", "monthCellTemplate", "yearCellTemplate", "decadeCellTemplate", "centuryCellTemplate", "weekNumberTemplate", "headerTitleTemplate"], outputs: ["activeViewChange", "navigate", "cellEnter", "cellLeave", "valueChange", "blur", "focus", "focusCalendar", "onClosePopup", "onTabPress", "onShiftTabPress"], exportAs: ["kendo-multiviewcalendar"] }, { type: i5.ActionSheetComponent, selector: "kendo-actionsheet", inputs: ["title", "subtitle", "items", "cssClass", "animation", "expanded", "titleId"], outputs: ["expandedChange", "expand", "collapse", "itemClick", "overlayClick"], exportAs: ["kendoActionSheet"] }, { type: i6.ResizeSensorComponent, selector: "kendo-resize-sensor", inputs: ["rateLimit"], outputs: ["resize"] }, { type: i7.ButtonComponent, selector: "button[kendoButton], span[kendoButton], kendo-button", inputs: ["arrowIcon", "toggleable", "togglable", "selected", "tabIndex", "imageUrl", "iconClass", "icon", "disabled", "size", "rounded", "fillMode", "themeColor", "svgIcon", "role", "primary", "look"], outputs: ["selectedChange", "click"], exportAs: ["kendoButton"] }], directives: [{ type: i8.DateRangePopupLocalizedMessagesDirective, selector: "[kendoDateRangePopupLocalizedMessages]" }, { type: i9.DateRangeSelectionDirective, selector: "[kendoDateRangeSelection]", inputs: ["autoCorrectOn", "selectionRange", "activeRangeEnd", "shouldSetRange"], outputs: ["activeRangeEndChange", "selectionRangeChange"] }, { type: i5.ActionSheetTemplateDirective, selector: "[kendoActionSheetTemplate]" }, { type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "13.3.12", ngImport: i0, type: DateRangePopupComponent, decorators: [{
            type: Component,
            args: [{
                    exportAs: 'kendo-daterange-popup',
                    providers: [
                        LocalizationService,
                        {
                            provide: L10N_PREFIX,
                            useValue: 'kendo.daterangepopup'
                        }
                    ],
                    selector: 'kendo-daterange-popup',
                    template: `
        <ng-container kendoDateRangePopupLocalizedMessages
            i18n-accept="kendo.daterangepopup.accept|The Accept button text in the timepicker component"
            accept="Set"

            i18n-acceptLabel="kendo.daterangepopup.acceptLabel|The label for the Accept button in the timepicker component"
            acceptLabel="Set time"

            i18n-cancel="kendo.daterangepopup.cancel|The Cancel button text in the timepicker component"
            cancel="Cancel"

            i18n-cancelLabel="kendo.daterangepopup.cancelLabel|The label for the Cancel button in the timepicker component"
            cancelLabel="Cancel changes"
        >
        </ng-container> 
        <ng-container #container></ng-container>
        <ng-template #defaultTemplate>
            <kendo-multiviewcalendar kendoDateRangeSelection (onClosePopup)="closePopup($event)" (onTabPress)="handleTab($event)" (onShiftTabPress)="handleShiftTab($event)"></kendo-multiviewcalendar>
        </ng-template>

        <kendo-actionsheet
            #actionSheet
            (overlayClick)="show=false"
            (collapse)="onBlur.emit()"
        >
            <ng-template kendoActionSheetTemplate>
                <!-- Resize sensor needs to be inside the template because the date-range-popup
                element itself always has 0x0 size and does not trigger the sensor. 
                Note: The popup in non-adaptive mode closes on window blur -->
                <kendo-resize-sensor *ngIf="isAdaptiveModeEnabled" (resize)="onResize()"></kendo-resize-sensor>
                <div class="k-actionsheet-titlebar">
                    <div class="k-actionsheet-titlebar-group k-hbox">
                        <div class="k-actionsheet-title">
                            <div class="k-text-center">{{ title }}</div>
                            <div class="k-actionsheet-subtitle k-text-center">{{ subtitle }}</div>
                        </div>
                        <div class="k-actionsheet-actions">
                            <button
                                kendoButton
                                type="button"
                                icon="x"
                                [attr.title]="localization.get('clearTitle')"
                                [svgIcon]="xIcon"
                                fillMode="flat"
                                [tabIndex]="-1"
                                aria-hidden="true"
                                size="large"
                                innerCssClass="k-button-icon"
                                (click)="show = false">
                            </button>
                        </div>
                    </div>
                </div>
                <div class="k-actionsheet-content !k-overflow-hidden">
                    <div class="k-scrollable-wrap">
                        <kendo-multiviewcalendar
                            class="k-calendar-lg"
                            orientation="vertical"
                            kendoDateRangeSelection
                            [shouldSetRange]="false">
                        </kendo-multiviewcalendar>
                    </div>
                </div>
                <div class="k-actions k-actions-stretched k-actions-horizontal k-actionsheet-footer">
                    <button kendoButton 
                        type="button"
                        size="large"
                        [attr.title]="localization.get('cancelLabel')"
                        [attr.aria-label]="localization.get('cancelLabel')"
                        (click)="show=false"
                    >
                        {{localization.get('cancel')}}
                    </button>

                    <button kendoButton
                        type="button"
                        size="large"
                        themeColor="primary"
                        [attr.title]="localization.get('acceptLabel')"
                        [attr.aria-label]="localization.get('acceptLabel')"
                        (click)="handleAccept()"
                    >
                        {{localization.get('accept')}}
                    </button>
                </div>
            </ng-template>
        </kendo-actionsheet>
    `
                }]
        }], ctorParameters: function () { return [{ type: i1.PopupService }, { type: i2.DateRangeService }, { type: i0.NgZone }, { type: i0.Renderer2 }, { type: i3.LocalizationService }, { type: i0.ChangeDetectorRef }, { type: undefined, decorators: [{
                    type: Optional
                }, {
                    type: Inject,
                    args: [RTL]
                }] }]; }, propDecorators: { container: [{
                type: ViewChild,
                args: ['container', { read: ViewContainerRef, static: false }]
            }], actionSheet: [{
                type: ViewChild,
                args: ['actionSheet']
            }], defaultTemplate: [{
                type: ViewChild,
                args: ['defaultTemplate', { static: false }]
            }], contentTemplate: [{
                type: ContentChild,
                args: [DateRangePopupTemplateDirective, { static: false }]
            }], dateRangeSelectionDirective: [{
                type: ViewChild,
                args: [DateRangeSelectionDirective, { static: false }]
            }], viewCalendar: [{
                type: ViewChildren,
                args: [MultiViewCalendarComponent]
            }], contentCalendar: [{
                type: ContentChildren,
                args: [MultiViewCalendarComponent]
            }], animate: [{
                type: Input
            }], anchor: [{
                type: Input
            }], anchorAlign: [{
                type: Input
            }], appendTo: [{
                type: Input
            }], collision: [{
                type: Input
            }], popupAlign: [{
                type: Input
            }], margin: [{
                type: Input
            }], adaptiveMode: [{
                type: Input
            }], title: [{
                type: Input
            }], subtitle: [{
                type: Input
            }], open: [{
                type: Output
            }], close: [{
                type: Output
            }], onBlur: [{
                type: Output,
                args: ['blur']
            }], onFocus: [{
                type: Output,
                args: ['focus']
            }], cancel: [{
                type: Output
            }] } });
